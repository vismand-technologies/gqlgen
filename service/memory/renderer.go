package memory

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sync"

	"github.com/99designs/gqlgen/internal/imports"
)

// MemoryRenderer renders templates to memory buffers instead of files
type MemoryRenderer struct {
	mu    sync.RWMutex
	files map[string][]byte
}

// NewRenderer creates a new memory renderer
func NewRenderer() *MemoryRenderer {
	return &MemoryRenderer{
		files: make(map[string][]byte),
	}
}

// RenderOptions contains options for rendering a template
type RenderOptions struct {
	PackageName     string
	Filename        string
	Template        string
	Data            interface{}
	GeneratedHeader bool
	FileNotice      string
	PackageDoc      string
	Imports         *MemoryImports
}

// Render renders a template to memory
func (r *MemoryRenderer) Render(opts RenderOptions) error {
	var buf bytes.Buffer

	// Write generated header
	if opts.GeneratedHeader {
		buf.WriteString("// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\n\n")
	}

	// Write package doc
	if opts.PackageDoc != "" {
		buf.WriteString(opts.PackageDoc)
		buf.WriteString("\n")
	}

	// Write package declaration
	buf.WriteString("package ")
	buf.WriteString(opts.PackageName)
	buf.WriteString("\n\n")

	// Write file notice
	if opts.FileNotice != "" {
		buf.WriteString(opts.FileNotice)
		buf.WriteString("\n\n")
	}

	// Write imports
	if opts.Imports != nil {
		buf.WriteString("import (\n")
		buf.WriteString(opts.Imports.String())
		buf.WriteString(")\n\n")
	}

	// Template content would go here
	// For now, write placeholder
	buf.WriteString("// Generated code will go here\n")

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, use unformatted
		formatted = buf.Bytes()
	}

	// Apply goimports-style import organization
	formatted, err = imports.Prune(opts.Filename, formatted, nil)
	if err != nil {
		// If import pruning fails, use previous version
		// This is okay for in-memory generation
	}

	// Store in files map
	r.mu.Lock()
	r.files[opts.Filename] = formatted
	r.mu.Unlock()

	return nil
}

// GetFiles returns all rendered files
func (r *MemoryRenderer) GetFiles() map[string][]byte {
	r.mu.RLock()
	defer r.mu.RUnlock()

	// Return a copy to prevent external modification
	result := make(map[string][]byte, len(r.files))
	for k, v := range r.files {
		result[k] = v
	}
	return result
}

// GetFile returns a specific rendered file
func (r *MemoryRenderer) GetFile(filename string) ([]byte, bool) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	content, ok := r.files[filename]
	return content, ok
}

// AddFile adds a file directly to the renderer
func (r *MemoryRenderer) AddFile(filename string, content []byte) {
	// Convert absolute path to relative path
	// This ensures ZIP files have clean relative paths instead of absolute ones
	relPath := filename
	if filepath.IsAbs(filename) {
		if wd, err := os.Getwd(); err == nil {
			if rel, err := filepath.Rel(wd, filename); err == nil {
				relPath = rel
			}
		}
	}

	r.mu.Lock()
	r.files[relPath] = content
	r.mu.Unlock()
}

// Clear removes all files from the renderer
func (r *MemoryRenderer) Clear() {
	r.mu.Lock()
	r.files = make(map[string][]byte)
	r.mu.Unlock()
}

// FileCount returns the number of files rendered
func (r *MemoryRenderer) FileCount() int {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return len(r.files)
}

// HasFile checks if a file exists
func (r *MemoryRenderer) HasFile(filename string) bool {
	r.mu.RLock()
	defer r.mu.RUnlock()
	_, ok := r.files[filename]
	return ok
}

// RenderString renders a template and returns the result as a string
func (r *MemoryRenderer) RenderString(opts RenderOptions) (string, error) {
	if err := r.Render(opts); err != nil {
		return "", err
	}

	content, ok := r.GetFile(opts.Filename)
	if !ok {
		return "", fmt.Errorf("file %s not found after rendering", opts.Filename)
	}

	return string(content), nil
}

// MergeFiles merges files from another renderer
func (r *MemoryRenderer) MergeFiles(other *MemoryRenderer) {
	otherFiles := other.GetFiles()

	r.mu.Lock()
	for filename, content := range otherFiles {
		r.files[filename] = content
	}
	r.mu.Unlock()
}

// RemoveFile removes a specific file
func (r *MemoryRenderer) RemoveFile(filename string) {
	r.mu.Lock()
	delete(r.files, filename)
	r.mu.Unlock()
}

// ListFiles returns a list of all filenames
func (r *MemoryRenderer) ListFiles() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()

	files := make([]string, 0, len(r.files))
	for filename := range r.files {
		files = append(files, filename)
	}
	return files
}
